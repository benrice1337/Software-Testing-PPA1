# Software-Testing-PPA1

Java functions are typically named in camelCase, so we named our test functions testFunctionToTest, where FunctionToTest was the name of the function in the code needing testing. In the event that such a function used a helper function, said helper function was tested in the same test function (see how testBodyMassIndex() encompasses both bodyMassIndex() and bmiCalculator()).

Install instructions:
1. Download the platform-appropriate Eclipse installer from https://www.eclipse.org/downloads/
2. Run the installer. If it prompts you to install Java, download and run the appropriate Java installer from the page it links you to.
3. Open Eclipse. Instead of creating a new project, click the option that lets you import a Github repo.
4. When the wizard asks you to give the repo link, go to the "Clone or download" button on the repo's main page and copy the link it provides you.
5. When the wizard asks you to associate the repo with a project, opt to create a new project. This will take you to the new project wizard.
6. In this wizard, give the project a name and change the storage location if you don't like the default.
7. When you're done creating the project, open PPA1.java and Tests.java. If Eclipse yells at you about JUnit 5 not being in the project build, click on the link to incorporate it. If it doesn't have one from just mousing over the error, mouse over your project in the package explorer, right-click, and go to Build Path > Add Library, which will bring up a window that lets you add JUnit 5.
8. To run tests, go to Tests.java and click the green play button in the ribbon. To run PPA1.java, go to PPA1.java and click the green play button.

Ben - This was my first time doing unit testing and TDD. These testing frameworks feel extremely user-hostile, sending me in circles for hours trying to install JUnit until I gave up and got Eclipse, which comes with it. And even once I got it, it felt underfeatured and hard to use: most of its functions are concerned with testing objects and data structures, not primitives. At least Eclipse made running the tests easy. For a low-level project like this, unit testing and TDD felt like a chore. For a bigger project, where implementation may not be straightforward, perhaps they would feel more useful. (Don't interpret that to mean that I want you to assign a harder programming project next time, though.) The nice thing about unit testing and TDD is that they boost your code correctness like crazy, but the drawback is that it's mind-numbingly tedious to test *every little thing*, and development time gets much, much longer.

Sean-Allen - Having never really tried to write unit tests before let alone attempt to write software using TDD methodolgy it felt very akward mentally to attempt this assignment. I can see in concept the usefullness of unit testing and TDD. Unit testing examines functionality in regards to testable units and is a fast automated way of making sure things are happening the way they should and that what's desired is being returned. TDD helps in designing the code intentionally to be moduled such that it is structured as testable units. But while these things can be good I honestly felt like I was slowed down alot mostly because of the fact that I have to write extra code for the tests and having to write the tests first and then design the functional code around those test was a really difficult adjustment. Overall though I do feel in a more complex project this would be usful but it would take some adjustment on my part to be become more efficient and reap the full benefits of be able to be thorough and confident with my code.
